
# Типы данных, операции и выражения.

## Краткие сведения о вводе/выводе в Си
Позже мы будем подробнее обсуждать средства ввода/вывода в языке Си. Пока что ограничимся двумя основными функциями: `scanf` и `printf`, которые определены в библиотеке `<stdio.h>`. Приведём пример использования каждого из них:

```c
#include <stdio.h>

int main() 
{
    printf("Input number: ");
    int a;
    scanf("%d", &a);
    printf("Your number is: %d\n", a);
    return 0;
}
```

Функции `printf` и `scanf` имеют следующие прототипы:

```c
int printf(const char *format, ...);
int scanf(const char *format, ...);
```

`const char *format` **пока** стоит воспринимать как строку, то есть последовательность символов заключённых в двойные кавычки, именно так в Си обозначают строки.

Строка `format` может включать в себя любой символ из **[ASCII таблицы](https://www.alpharithms.com/s3/assets/img/ascii-chart/ascii-table-alpharithms-scaled.jpg)**, так называемые escape-последовательности а также спецификаторы. 
В нашем примере 
- `%d` - спецификатор целого знакового числа `int` с остальными можно ознакомиться по [ссылке](https://learn.microsoft.com/ru-ru/cpp/c-runtime-library/format-specification-syntax-printf-and-wprintf-functions?view=msvc-170). Обратите внимание на возможность вывода чисел в системах счисления родственных двоичной.
- `\n` - escape-последовательность, переводит каретку вывода на следующую строку.
- Все остальные символы в двойных кавычках входят в **ASCII таблицу**  

После строки `format` стоит многоточие - оно обозначает переменное количество аргументов. На месте эого многоточия используются переменные типов согласованных с спецификаторами, то есть

```c
double a;
scanf("%d\n", &a);
```

выдаст ошибку о несоответствии спецификатора типу выводимой переменной. Корректный вариант ниже

```c
double a;
scanf("%lf\n", &a);
```

Переменные сопоставляются спецификаторам по порядку, и их может быть любое количество. Обратим внимание на то, что при выводе (вызове функции `scanf`) перед переменными ставится символ `&` (амперсанд).

На ближайшее время этой информации о вводе выводе достаточно.

## Типы данных и их размеры

В языке Си существуют следующие основные типы, ниже приведены краткие описания каждого, размеры их представления в памяти компьютера в порядке неубывания, и модификаторы, применимые к ним. 
- `char` - символьный тип, 1 байт, `signed`, `unsigned`.
- `int` - целочисленный тип, 4 байта, `signed`, `unsigned`, `short` - 2 байта, `long` - 4 или 8 байт.
- `float` - числа с плавающей точкой, 4 байта, нет модификаторов
- `double` - числа с плавающей точкой с двойной точностью, 8 байт, `long` - 64 байта.
Чтобы посмотреть диапазоны значений типов, можно сделать например так:

```c
#include <stdio.h>
#include <limits.h>

int main() 
{
    printf("INT_MAX = %d\nINT_MIN = %d\n", INT_MAX, INT_MIN);
    return 0;
}
```

Запускаем и получаем такой результат (на MacOS):

```console
bash-3.2$ gcc 1.c -o main
bash-3.2$ ./main
INT_MAX = 2147483647 
INT_MIN = -2147483648
```
Надо подчеркнуть, что `long` не обязан быть 8-байтным, то есть он может быть такого же размера, что и `int`. На этот случай есть модификатор `long long`, который обязан быть размером 8 байт.

> ### Задание
> Проверьте, какого размера на вашем компьютере основные типы данных: `char`, `short`, `int`, `long`, `long long`, `float`, `double`, `long double`. Для этого используйте функцию `int sizeof(type)`, которая принимает на вход тип данных (`type`), а возвращает размер в байтах. 

## Константы

Часто в программах требуется вводить константы. Необходимость их применения почти всегда зависит от контекста. В качестве примера можно привести значение разности между градусами цельсия и градусами Кельвина. 

Наиболее частые способы задания констант: 
- перечисляемые константы `enum`
- директива `#define`
- модификатор `const`

Проиллюстрируем ранее приведённый пример программой. 

```c
#include <stdio.h>

enum
{
    CELSIUS_TO_KELVIN = 273
};

// const int CELSIUS_TO_KELVIN = 273;

// #define CELSIUS_TO_KELVIN = 273;

int main()
{
    printf("Input celsius degrees: ");
    int celsius;
    scanf("%d", &celsius);
    printf("Your degree in kelvin: %d\n", celsius + CELSIUS_TO_KELVIN);
    return 0;
}
```

## Объявление переменных и правила их именования


Все переменные надо объявлять до момента их использования. В объявлении указываются тип и список имён одной или нескольких переменных. 
Объявление и инициализация это разные вещи. Для наглядности различий приведём пример. 

```c
#include <stdio.h>

int main()
{
    int a; // объявление
    a = 5; // инициализация
    int b = 5; // объявление и инициализация


    return 0;
}
```

Имя переменной может состоять из букв, цифр и '\_'. Начинаться имя может только с буквы и '\_', но начинать имя с '\_' не рекомендуется.

Также переменные можно поделить по тому, где они обявлены. При такой классификации они делятся на **глобальные** и **локальные** (автоматические).  

```c
#include <stdio.h>

int a; // глобальная переменная (global variable)

int main() 
{
    int b; // локальная переменная (local/automatic variable)

    return 0;
}
```
Рaзницу между глобальными и локальными переменными мы разберём позже. Пока что требуется просто запомнить их определения.

Группировать объявления переменных можно также разными способами, то есть такое объявление 
```c
int a, b, c;
char ch1, ch2; 
```
и такое 
```c
int a; // удобный комментарий 1
int b; // удобный комментарий 2
int c; // удобный комментарий 3
char ch1; // удобный комментарий 4 
char ch2; // удобный комментарий 5
```
являются эквивалентными. Преимущество первой - компактность, во втором же случае удобнее комментировать строки кода. 

## Арифметические, битовые и логические операторы

### Арифметические операторы 
| Оператор  |  +   |  -   |   *  |   /  |   %  |  ++  |  --  |  =   |
| :--:      | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| Значение  | Сложение | Вчитание | Умножение | Деление | Остаток | Инкремент | Декремент | Присваивание |

Проиллюстрируем некоторые арифметические операторы небольшой программой
```c
#include <stdio.h>

int main() 
{
    int a = 7;
    int b = 9;
    printf("b / 7 = %d\ta * b = %d\n", b / 7, a * b);
    printf("%d %d\n", a, b);
    int tmp = ++a;
    printf("%d %d\n", tmp, a);
    tmp = b++;
    printf("%d %d\n", tmp, b);
    return 0;
}
```
Вывод имеет следующий вид:
```console
b / 7 = 1	a * b = 63
7 9
8 8
9 10
```

В данном выше примере предлагается обратить внимание на две формы инкрементирования: преинкремент и постинкремент. 
Прификсная форма характеризуется тем, что он сначала возвращает увеличенное на единицу значение а потом кладёт его в 
переменную, к которому оно применяется. В случае постфиксной формы сначала возвращается текущее значение переменной а 
потом в саму переменную кладётся значение увеличенное на один.

### Битовые операторы

|Оператор| & | \| | ^ | << | >> | ~ |
| :-: | :-: | :-: | :-: | :-: | :-: | :-: |
|Значение| Побитовая конъюнкция | Побитовая дизъюнкция | Побитовое сложение по модулю 2 | Побитовый сдвиг влево | Побитовый сдвиг право | Побитовая инфертация | 

С побитовыми операциями стоит быть осторожным, так как здесь кроется множество нюансов. Прежде чем использовать какой-либо 
побитовый оператор рекомендуется прочитать справку по нему. 

Приведём иллюстрирующую программу: 
```c
#include <stdio.h>

int main()
{
    int a = 6; // 0110
    int b = 9; // 1001
    printf("%d %d %d %d %d %d\n", a & b, a | b, a ^ b, ~a, a >> 2, a << 3);      
    return 0;
}
```
Результат следующий: 
```console
0 15 15 -7 1 48
```
Обратите внимание на отрицательное значение, полученное в результате побитового инвертирования.

> #### Замечание
> Любой оператор может быть употреблён в подобной форме с оператором присваивания: `+=`
> 
> Приведём пример
> ```c
> #include <stdio.h>
> int main()
> {
>     int a = 5;
>     printf("%d", a);
>     a += 4;
>     printf("%d", a);
>     a /= 2;
>     printf("%d", a);
>     a <<= 2;
>     printf("%d", a);
>     a ^= 5; 
>     printf("%d\n", a);
>     return 0;
> } 
> ```
> Вывод:
> ```console
> 5 9 4 16 21
> ```

### Логические операторы

|Оператор| < | <= | > | >= | == | != | && | \|\| | 
| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
|Значение| Меньше | Меньше или равно | Больше | Больше или равно | Равно | Не равно | Конъюнкция | Дизъюнкция | 

Все логические операторы возвращают значение 1 или 0, то есть вывод программы 
```c
#include <stdio.h>

int main() 
{
    int a = 5;
    int b = 7;
    printf("%d %d %d %d %d %d\n", a < b, a <= b, a > b, a >= b, a == b, a != b);
    return 0;
}
```
будет таким
```console
1 1 0 0 0 1
```

## Преобразование типов 

Если операнды оператора относятся к разным типам данных, то они преобразуются к одному типу при помощи нескольких правил:
1. Если какой-либо из операндов имеет тип `long double`, то и другой приводится к `long double`.
2. Иначе, если какой-либо из операндов имеет тип `double`, то и другой приводится к `double`.
3. Иначе, если какой-либо из операндов имеет тип `float`, то и другой приводится к `float`.
4. Иначе, если какой-либо из операндов имеет тип `unsigned long`, то и другой приводится к `unsigned long int`.
5. Иначе, если один из операндов имеет тип `long int`, а другой `unsigned int`, тогда 
    - если `long int` представляет все значения `unsigned int`, то `unsigned int` приводится к `long int` 
    - иначе оба операнда преобразуются в `unsigned long int`;
6. Иначе, если какой-либо из операндов имеет тип `long int`, то и другой приводится к `long int`. 
7. Иначе, если какой-либо из операндов имеет тип `unsigned int`, то и другой приводится к `unsigned int`.
8.  Иначе, оба операнда имеют тип `int`

## Приоритет операций 

|Операции|
| :-: |
|() &nbsp; [] &nbsp; -> &nbsp; .|
| ! &nbsp; ~ &nbsp; ++ &nbsp; -- &nbsp; + &nbsp; - &nbsp; * &nbsp; & &nbsp; (type) &nbsp; sizeof |
| * &nbsp; / &nbsp; % |
| + &nbsp; - |
| << &nbsp; >> |
| < &nbsp; &nbsp; <= &nbsp; > &nbsp; >= |
| == &nbsp; != |
| & |
| ^ |
| \| |
| && |
| \|\| |
| ?: |
| = &nbsp; += &nbsp; -= &nbsp; *= &nbsp; /= &nbsp; %= &nbsp; &= &nbsp; ^= &nbsp; |= &nbsp; <<= &nbsp; >>= |
| , |


