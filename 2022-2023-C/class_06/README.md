# Структуры

Структуры - это совокупность переменных часто различных типов сгруппированных под одним именем. Структуры могут
потребоваться например при работе с сложными составными объектами. Например, такими как субъект государства. У каждого
субъекта есть много характеристик: название, население, географическое положение (координаты), бюджет, глава и так далее.
Поэтому хранить все эти данные в массиве будет крайне неудобно.

## Основы работы

Проиллюстрируем основы работы с структурами на примере элементарной геометрии на плоскости.

1. Объявление структуры:
```c
struct метка-структуры 
{
    тип-поля1 имя-поля1;
    тип-поля2 имя-поля2;
    ...
    тип-поляN имя-поляN;
}; // объявление структуры
```

2. Создание структуры определенного ранее типа:
```c
struct метка-структуры имя-переменной; // создание структуры
```

3. Обявление и создание структуры данного типа одновременно: 
```c
struct метка-структуры { // объявление структуры
    описание полей структуры
} имя1, имя2, ..., имяN; // создание структуры
```

4. Обращение к полю структуры происходит при помощи `.`:

```c
имя-структуры.поле
```

Важно, что полем структуры не может быть та же структура (не путать с указателем на неё).

Размер структуры можно узнать при помощи того же опрератора `sizeof()` как для переменной типа данной структуры так и от 
самой этой структуры. 

## Массивы структур

Напишем программу, которая будет считывать со стандартного потока ввода количество точек на плоскости, затем их 
координаты (в декартовой системе координат). Результатом работы будет отсортированный массив введённых точек 
(по полярному расстоянию). 

```c
#include <stdio.h>
#include <stdlib.h>

struct Point
{
    double x;
    double y;
};

int 
cmp(const void *a, const void *b)
{
    struct Point p1 = *(struct Point *) a;
    struct Point p2 = *(struct Point *) b;
    double r1 = p1.x * p1.x + p1.y * p1.y;
    double r2 = p2.x * p2.x + p2.y * p2.y;
    if (r1 > r2) {
        return 1;
    } else if (r1 == r2) {
        return 0;
    }
    return -1;
}

int
main() 
{
    struct Point points[5];
    for (int i = 0; i < 5; ++i) {
        scanf("%lf%lf", &points[i].x, &points[i].y);
    }
    qsort(points, 5, sizeof(*points), cmp); 
    for (int i = 0; i < 5; ++i) {
        printf("%lf %lf\n", points[i].x, points[i].y);
    }


    return 0;
}
```
 
Остановимся подробнее на функции `qsort` из библиотеки `<stdlib.h>`. Она имеет следующий прототип (его можно узнать 
в мануале **Linux**):

```c
void
qsort(void *base, size_t nel, size_t width, int (*compar)(const void *, const void *));
```

1. `void *base` - указатель на начло массива для сортировки
2. `size_t nel` - количество элементов (*number of elements*)
3. `size_t width` - размер (в байтах) каждого
4. `int (*compar)(const void *, const void *)` - указатель на функцию-компаратор.

Функция-компоратор - функция, которая согласно обзепринятым правилам принимает два последовательных элемента из массива и 
возвращает `1` - если первый из них больше второго, `0` - если равны, `-1` - если первый меньше второго.

Внутри функции компаратора, мы приводим `void *` к нужному нам типа `double` и производим необходимое сравнение.

## Оператор typedef

Чтобы не писать целиком `struct метка-структуры` каждый раз для объявления структуры можно воспользоваться оператором 
`typedef`. Например таким образом:

```c
typedef struct Node
{
    int key;
    struct Node *left_child;
    struct Node *right_child; 
} Node;
```
 
После этого объявить любую переменную типа `struct Node` можно так `Node my_node`. 

Также в языке Си есть типы похожие на структуры - объединения и битовые поля. Пока что мы их рассматривать не будем.















































































































































