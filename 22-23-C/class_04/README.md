# Функции и структура программы

Сначала о том, что такое функции и зачем они нужны. 
В общем функция это отображение из множества **A** в множество **B** по некоторому правилу. Например, **f(x) = x^2^** - это 
функция. 

Зачем же нужны функции в программировании? Поставим следующую задачу: 
*Дана матрица (таблица чисел) **n &#215; m**, в которой требуется отсортировать каждую строку.* 
Решение очевидно, мы просто запустим цикл по всем строкам и 
отсортируем каждую. Но что если потом нам ввели еще одну матрицу
другого размера, после ещё одну, и так далее. Каждый раз реализовывая приведение матрицы от исходного вида к требуеммому, где отсортированы элементы внутри строки, мы переписываем по сути
один и тот же код. 

Тут на помощь приходят функции. В данном случае функция будет реализовывать отображение из множества матриц некоторого размера в множество матриц такого же размера **НО** в котором, каждая матрица имеет требуемый вид. То есть мы можем не переписывать один и тот же код несколько раз.

## Основы создания функций

Определение функции имеет следующий вид:

```c
тип-возвращаемого-значения 
имя-функции(арг1, арг2, другие аргументы)
{
    тело функции
}
```

Ниже пример простой функции `foo`, которая принимает на вход натуральное число **n** и выводит все значения от 1 до **n**.

```c
void foo(int n) {
    for (int i = 1; i <= n; ++i) {
        printf("%d ", i);
    }
    printf("%d\n");
}
```

> Обратите внимание на тип возвращаемого значения `void`. Он 
> означает "ничего". То есть функция `foo` ничего не возвращает.

Напишем еще одну функцию `foo1`, которая принимает на вход два 
натуральных числа **a** и **b** и возвращает их максимум.

```c
int foo1(int a, int b) {
    return a > b ? a : b;
}
```

> В функции `foo1` появился оператор `return`. Именно он отвечает за 
> возврат значения того типа, который указан в возвращаемом типе. 

Мы научились определять функции, теперь научимся ими пользоваться
(вызывать их). 

```c
int main() {
    int a, b;
    scanf("%d%d", &a, &b);
    printf(max(a, b));
}
```

> Обратите внимание на то, что в теле функции `main` отсутствует 
> оператор `return`. В этом смысле функция `main` особенная. 

Стоит также сказать про преобразование типов оператором `return`.

```c
#include <stdio.h>
int foo() {
    return 5.5;
}
int main() {
    printf("%d\n", foo());
    return 0;
}
```

Код ниже выдаст предупреждение.
```console
2.c:6:12: warning: implicit conversion from 'double' to 'int' changes value from 5.5 to 5 [-Wliteral-conversion]
    return 5.5;
    ~~~~~~ ^~~
1 warning generated.
```

Чтобы этого не произошло достаточно добавить явное преобразование в операторе `return`

```c
#include <stdio.h>
int foo() {
    return (int) 5.5;
}
int main() {
    printf("%d\n", foo());
    return 0;
}
```

Таким образом компилятор точно понимает, что Вы осуществляете
осознанное приведение типов. 

## Глобальные и локальные переменные (автоматические). Область видимости переменных. 

Переменные в языке Си можно разделить на две категории: глобальные и локальные (также называемые автоматическими). 

Область видимости имени - это часть программы в пределах которой можно использовать имя. Для автоматической переменной, объявляемой в начале функции, областью видимоти является эта функция. Локальные переменные с одинаковыми именами, объявленные в разных функциях, не имеют никакого отношения друг к другу. То же самое верно и для параметров функций, которые по сути являются локальными переменными.

Так, возвращаясь к примеру функции `max(int a, int b)` можно сказать, что локальные переменные 
`a` и `b` в теле функции `main` не имеют никакого отношения к аргументам данной функции. 

Область действия шлобальной переменной или функции распространяется от точки, в которой она 
была *объявлена*, до конца компилируемого файла. Например имеем следующую программу:

```c
int main() {}

int var;
```

Переменная `var` является глобальной, но из функции `main` обратиться к ней мы не можем. 
Если нужно обратиться к переменной `var` до её *определения* или если она *определена* в другом файле исходного кода, то нужно вставить объявление с ключевым словом `extern`. Таким образом можно переписать код выше так:

```c
extern int var;
int main() {
    printf("%d\n", ++var);
}
int var;
```

В листинге выше можно увидеть наглядную разницу между *объявлением* и *определением*. 

- `extern int var;` - объявление переменной целого типа
- `int var;` - определение переменной целого типа

Пока что данной информации о глобальных и локальных переменных и их областях видимости нам достаточно.


## Заголовочные файлы. 

Попробуем теперь написать программу состоящую из нескольких файлов. Это бывает необходимо 
для тестирования решения, когда в условии задачи просят написать лишь какую-то функцию.

Файл `main.c`:

```c
#include <stdio.h>
#include "help.h"

int main() {
    int a, b;
    scanf("%d%d", &a, &b);
    printf("max(a, b) = %d\n", max(a, b));
}
```

Файл `help.h`:

```c
int max(int a, int b);
```

Файл `help.c`:

```c
#include "help.h"
int max(int a, int b) {
    return a > b ? a : b;
}
```

Компилируется и выполняется эта программа следующим образом:

```console
% gcc main.c help.c -o main
% ./main
3 8
max(a, b) = 8
```

Приведём еще один, чуть более сложный пример. Вычисление чисел Фиббоначи. 

Файл `fib_main.c`:

```c
#include <stdio.h>
#include "fib_help.h"

extern int n;

int main() {
    scanf("%d", &n);
    printf("%d\n", fib());
    return 0;
}
```

Файл `fib_help.h`:

```c
int n;
int fib(void);
```

Файл `fib_help.c`:

```c
#include "fib_help.h"

int fib(void) {
    if (n == 0) return 0;
    if (n == 1) return 1;
    int prev = 0, cur = 1;
    for (int i = 2; i <= n; ++i) {
        int tmp = cur;
        cur += prev;
        prev = tmp;
    }
    return cur;
}
```

Компиляция и выполнение программы:

```console
% gcc fib_main.c fib_help.c -o main
% ./main
13
233
```

## Статические переменные


Если объявление внешней переменной или функции содержит слово `static`, её область действия 
ограничивается данным файлом исходного кода - от точки объявления до конца. Таким образом, внешние статические переменные - это механизм сокрытия имён. Статическое хранение переменной в памяти задаётся ключевым словом `static` в начале обычного объявления.

Также переменные с спецификатором `static` обладают следующим свойством: память под них выделяется одныжды при объявлении.
Проиллюстрируем ниже:

```c
#include <stdio.h>

void foo(int n) {
    static int cur = 0;
    if (cur > n) return;
    printf("%d\n", cur++);
    foo(n);
}

int main() {
    int n;
    scanf("%d", &n);
    foo(n);
}
```

Данныя программа печатает все числа от **0** до **n** включительно.
Вывод:

```console
% gcc 3.c -o main
% ./main
5
0
1
2
3
4
5
```

## Рекурсия

Функции в языке Си могут использоваться рекурсивно, то есть функция может вызывать сама себя прямо или косвенно. При каждом рекурсивном вызове в функции создаётся новый набор локальным переменных, независимый от предыдущего.

Приведём пример:

```c
#include <stdio.h>

void print(int n) {
    if (n < 0) {
        n *= -1;
        printf("-");
    }
    if (n / 10) {
        print(n / 10);
    } 
    printf("%c ", n % 10 + '0');
}

int main() {
    int n;
    scanf("%d", &n);
    print(n);
    printf("\n");
    return 0;
}
```

Программа выше считывает с консоли число, а после выводит все его цифры через пробел.

Рекурсия относительно циклов сильно расходует память, она медленнее чем цикл. Но при этом рекурсивный код более компактный, читаемый и легко 
поддерживаемый. Чаще всего рекурсия используется для работы с структурами 
данных, такими как списки, деревья, графы.

## Препроцессор языка Си

Препроцессирование - по существу первая стадия компиляция программ на языке
Си. Мы уже занкомы с директивами препроцессора `#include` (подключает все содержимое файла в код, внутри которого используется) и `#define` (заменяет идентификатор заданной последовательностью символов). Также
препроцессор позволяет реализовать условную компиляцию и макросы с 
аргументами.

### Включение файлов

Включение файлов задаётся одной из следующих строк в исходном коде:

```c
#include "имя_файла"
#include <имя_файла>
```

Отличие состоит в том, что если имя подключаемого файла заключено в кавычки,
то поиск файла начинается с того места, где находится исходный текст 
программы. Если его там нет или если имя файла заключено в угловые скобки, то поиск файла продолжается по правилам, прописанным в реализации языка. В свою
очередь подключаемый файл также может содержать директивы `#include`. 

### Макроподстановки

Следующая конструкция задаёт макроопределение (или макрос):

```c
#define имя текст-для-замены
```

Всякий раз когда в тексте программы после этого определения встретится *имя*,
оно будет заменено на *текст-для-замены*. Обычно *текст-для-замены* помещается на одной строке, но если нет, то можео использовать символ `\`, например так:

```c
#define имя текст-для-замены \
            продолжение-текста-для-замены
```

Приведём некоторые макросы:

```c
#define forn(i, N) for (int (i) = 0; (i) < (N); ++(i))
#define max(A, B) ((A) > (B) ? (A) : (B))
#define ll long long
#define newline printf("\n")
```
и так далее...

Но также стоит уберечься от часто встречаемых на практике ошибок, например:

- `#define square(x) x * x` - в этом случае, если встретится участок кода 
`square(n + 1)`, то нарушится порядок вычислений, и мы получим не то, что ожидали.
- `max(a++, b--)` - в этом случае большее значение будет увеличено на 2, а не на один, как ожидалось. 

### Условное включение 

Существует возможность управлять самой препроцессорной обработкой, используя
условные директивы, которые выполняются по ходу этой обработки. Это делает возможным условное включение фрагментов кода в программу в зависимости от условий, выполниющихся на момент компиляции. 

В директиве `#if` выполняется проверка целочисленного выражения (которое не должно содержать операцию `sizeof`, приведение типов и константы, определенные через `enum`). Если выражение истинно, то в программу включаются все директивы
до ближайшей `#edif` или `#elif` или `#else`. Выражение `defined(имя-файла)` 
равно истине, если файл уже включён в программу, иначе ложь.

Пример использования условной компилыции:

```c
#if SYSTEM == SYSV
    #define HDR "sysv.h"
#elif SYSTEM == BSD
    #define HDR "bsd.h"
#elif SYSTEM == MSDOS
    #define HDR "msdos.h"
#else
    #define HDR "default.h"
#endif
#include HDR
```

В данном примере, мы проверяем, чему равно `SYSTEM` и в зависимости от этого подключаем определённый заголовочный
файл.



















