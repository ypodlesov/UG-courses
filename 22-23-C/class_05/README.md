# Указатели и массивы

## Указатели и адреса 
Мы будем исходить из предположения, что вся память компьютера - это 
бесконечный массив, каждый элемент которого - байт, в котором индекс некоторое целое число от 
нуля до бесконечности соответственно.
При таком прдеположении проще понять то, что такое указатель в языке Си. 
Возьмём любой произвольный тип данных, например тип `int`. Как правило он
имеет размер 4 байта. Соответственно он будет располагаться на некоторой 
позиции в нашем массиве и занимать 4 ячейки. Обратиться к ней мы можем при 
помощи имени, которым её объявили. Но указатели позволяют ещё один способ. 

Механизм следующий - объявляется указатель - просто число, смысл которого индекс ячейки начиная 
с которой располагается переменная, на которую он указывает.
Тип указателя означает сколько байт располагается по хранимому адресу.

Объявить указатель можно следующим образом: 

```c
тип-переменной *имя-переменной;
```

Чтобы инициализировать указатель можно воспользоваться унарной операцией `&`:

```c
int a = 5;
int *p = &a;
```

Эта запись эквивалентна следующей:

```c
int a = 5;
int *p;
p = &a;
```

Оператор `*` называется оператором разыменованием указателя. Таким образом мы 
получаем содержимое ячейки на которую он указывает. 

У каждой переменной кроме адреса есть ещё и тип. Этот тип при операции разыменования указателя позволяет понять, в 
скольких последующих байтах располагается содержимое. 

Например:

```c
short a = 5;
short *pa = &a;
printf("%hi\n", *pa);
```

Благодаря тому, что мы объявили указатель на `short` (который обычно занимает 2 байта), мы получаем корректные данные, 
данные из первых двух байт.

Выводить указатели можно с спецификатором `%p`.

```c
int a = 3;
int *pa = &a;
printf("%p\n", pa);
```

Выведется адрес переменной **a**.

## Указатели и аргументы функций. 

Теперь поговорим про одно из применений указателей. 

Предположим мы хотим написать функцию обмена значений переменных. 
Попробуем реализовать её так:

```c
void swap(int a, int b) {
    int tmp = a;
    a = b;
    b = tmp;
}
```

Если мы запустим её от любых аргументов, мы не получим желаемое (почему?). 
Тут на помощь приходят указатели. Корректная реализация функции `swap` выглядит следующим образом:

```c
void swap(int *a, int *b) {
    int tmp = *a;
    *a = *b;
    *b = tmp;
}
```
Вызыв функции:
```c
int main() {
    int a = 4, b = 7;
    swap(&a, &b);
    printf("%d %d\n", *a, *b);
}
```

Как это работает? 

Функция `swap` создаёт локальные копии указателей с значением равным **&a** и **&b** соответственно. То есть при
разыменовании этих указателей мы получаем содержимое ячеек, в которых лежат **a** и **b**. Следовательно каждый раз, 
обращаясь к **\*a** или **\*b**, мы работает с оригинальными переменными **a**, **b**.

## Указатели и массивы.

Массив в языке Си - это структура данных содержащая элементы одного типа и находящиеся в последовательном порядке.
Каждый элемент определяется своим индексом (порядковым номером), начиная с **0** до **size - 1**, где **size** - 
это количество элементов в массиве.
Создание массива:

```c
тип-элементов имя-массива[количество-элементов];
```

Количество элементов в данном случае очень желательно должно быть константым выражением. 
Обращаться и изменять элементы массива можно по индексу (и не только, но об этом чуть позже) `имя-массива[индекс]`.

Программа считывает число элементов в массиве. Создаёт массив на это количество. Потом считывает каждый элемент, 
записывает его в массив, а после вычисляет сумму всех элементов массива.

```c
#include <stdio.h>

int main() {
    int n; // number of elements in array
    scanf("%d", &n);
    int a[n]; // declare an array
    for (int i = 0; i < n; ++i) {
        scanf("%d", &a[i]);
    }
    long long sum = 0; // initialize sum of elements in the array
    for (int i = 0; i < n; ++i) {
        sum += a[i];
    }
    printf("%lld\n", sum);
    return 0;
}
```

Образом показанным выше можно создавать массив не только переменных целого типа (`int`), но и любого другого. 

Теперь остановимся подробнее на связи массивов и указателей. На самом деле мы можем работать с массивом, используя лишь
указатель на его начало и сдвиг от него же. Программу выше можно переписать.

```c
#include <stdio.h>

int main() {
    int n; // number of elements in array
    scanf("%d", &n);
    int a[n]; // declare an array
    for (int i = 0; i < n; ++i) {
        scanf("%d", (a + i));
    }
    long long sum = 0; // initialize sum of elements in the array
    for (int i = 0; i < n; ++i) {
        sum += *(a + i);
    }
    printf("%lld\n", sum);
    return 0;
}
```

Такой подход также известен как адресная арифметика. В данном случае пример надуманный, но часто этот подход бывает 
опраданным. 

## Кратко об основах управления памятью в языке Си. Стек и куча.

Управление памятью в языке Си - сложная и весьма обширная тема. В рамках нашего курса мы ограничимся лишь некоторыми 
основами необходимыми для эффективной работы наших программ. 
Условно память, которую мы используем в нашей программе можно разделить на два типа: **стек** и **куча**. Все локальные
переменные располагаются на стеке. Чтобы расположить какую-либо переменную в куче (на куче) нужно использовать 
специальные функции (о них чуть позже). 

### Принцип работы стека. 

Стек — это область оперативной памяти, которая создаётся для каждого потока. Он работает в порядке LIFO 
(Last In, First Out), то есть последний добавленный в стек кусок памяти будет первым в очереди на вывод из стека. 
Каждый раз, когда функция объявляет новую переменную, она добавляется в стек, а когда эта переменная пропадает из 
области видимости (например, когда функция заканчивается), она автоматически удаляется из стека. 
Когда стековая переменная освобождается, эта область памяти становится доступной для других стековых переменных.

Из-за такой природы стека управление памятью оказывается весьма логичным и простым для выполнения на ЦП; это приводит 
к высокой скорости, в особенности потому, что время цикла обновления байта стека очень мало, 
то есть этот байт скорее всего привязан к кэшу процессора. Тем не менее, у такой строгой формы управления есть и 
недостатки. Размер стека — это фиксированная величина, и превышение лимита выделенной на стеке памяти приведёт к 
переполнению стека. Размер задаётся при создании потока, и у каждой переменной есть максимальный размер, зависящий 
от типа данных. Это позволяет ограничивать размер некоторых переменных (например, целочисленных), и вынуждает заранее
объявлять размер более сложных типов данных (например, массивов), поскольку стек не позволит им изменить его. Кроме 
того, переменные, расположенные на стеке, всегда являются локальными. 

### Принцип работы кучи. 

Куча — это хранилище памяти, также расположенное в ОЗУ, которое допускает динамическое выделение памяти и не работает 
по принципу стека: это просто склад для ваших переменных. Когда вы выделяете в куче участок памяти для хранения 
переменной, к ней можно обратиться не только в потоке, но и во всем приложении. Именно так определяются глобальные 
переменные. По завершении приложения все выделенные участки памяти освобождаются. Размер кучи задаётся при запуске 
приложения, но, в отличие от стека, он ограничен лишь физически, и это позволяет создавать динамические переменные.

В сравнении со стеком, куча работает медленнее, поскольку переменные разбросаны по памяти, а не сидят на верхушке 
стека. Некорректное управление памятью в куче приводит к замедлению её работы; тем не менее, это не уменьшает 
её важности — если вам нужно работать с динамическими или глобальными переменными, пользуйтесь кучей.

### Функции для работы с динамической памятью (кучей).

Для работы с кучей существуют функции: `malloc`, `calloc`, `free`, `realloc`. Все они объявлены в заголовочном файле 
`stdlib.h`.

Подробное описание каждой Вы можете посмотреть в мануале **Linux**. Мы же приведём прототип и краткую информацию о 
каждой. 
Функции `malloc` и `calloc`:

```c
void *calloc(size_t count, size_t size);
void *malloc(size_t size);
```

`calloc` принимает на вход количество элементов `size_t count` и размер каждого (в байтах) `size_t size`. 
`size_t` - всегда беззнаковый тип, определённый примерно таким образом:

`malloc` принимает на вход просто количество байт, которое нужно выделить в динамической памяти.

```c
typedef unsigned int size_t;
или 
typedef unsigned long size_t;
или 
typedef unsigned long long size_t;
```

Тип указателя `void` может быть приведён к указателю любого типа.

После вызова этих функций мы можем работать с выделенной памятью, как с обычным массивом. Типичный пример использования
функции `calloc`:

```c
#include <stdio.h>
#include <stdlib.h>

int main()
{
    int n;
    scanf("%d", &n);
    int *a = calloc(n, sizeof(int));
    for (int i = 0; i < n; ++i) {
        scanf("%d", &a[i]);
    }
    for (int i = n - 1; i >= 0; --i) {
        printf("%d ", a[i]);
    }
    printf("\n");
    return 0;
}
```

Любой запрос память на куче при помощи `calloc` или `malloc` должен сопровождаться соответствующим ровно **одним** 
вызовом функции 
`free`. 

```c
void free(void *ptr);
```

Функция принимает на вход указатель на область (выделенной ранее) динамической память, которую следует освободить. Функция ничего не 
возвращает. Освобождение памяти более одного раза повлечёт за собой ошибку. 

Теперь можно сказать, что программа выше некорректна, так как в ней не освобождается выделенная динамическая память.

Перепишем программу. 

```c
#include <stdio.h>
#include <stdlib.h>

int main()
{
    int n;
    scanf("%d", &n);
    int *a = calloc(n, sizeof(int));
    for (int i = 0; i < n; ++i) {
        scanf("%d", &a[i]);
    }
    for (int i = n - 1; i >= 0; --i) {
        printf("%d ", a[i]);
    }
    printf("\n");
    free(a);
    return 0;
}
```

Теперь предположим, что размер нашего массива может меняться во время исполняемой программы, и мы не хотим занимать 
лишнюю динамическую память. Для этого есть функция `realloc`.

```c
void *realloc(void *ptr, size_t size);
```

Она принимает на вход указатель на память, размер которой требуется изменить `void *ptr`, и новый размер (в байтах) 
`size_t size`.
Приведём пример её работы:

```c
#include <stdio.h>
#include <stdlib.h>

int
main()
{
    int n;
    scanf("%d", &n);
    int *a = calloc(n, sizeof(int));
    for (int i = 0; i < n; ++i) {
        scanf("%d", &a[i]);
    }
    for (int i = n - 1; i >= 0; --i) {
        printf("%d ", a[i]);
    }
    printf("\n");
    int m;
    scanf("%d", &m);
    a = realloc(a, m * sizeof(*a));
    for (int i = 0; i < m; ++i) {
        scanf("%d", &a[i]);
    }
    for (int i = m - 1; i >= 0; --i) {
        printf("%d ", a[i]);
    }
    printf("\n");
    free(a);

    return 0;
}
```

## Многомерные массивы. 

В языке Си есть возможность создавать многомерные массивы. Например, матрицы (таблицы из чисел) можно хранить в памяти 
как двумерный массив. 

Пример: на стандартный поток вывода вводится число **n** - порядок квдратной матрицы. Далее вводятся **n** строк по **n** 
чисел - элементы матрицы. Транспонируйте данную матрицу и выведите её на экран.

```c
#include <stdio.h>
#include <stdlib.h>

void 
swap(int *a, int *b)
{
    int tmp = *b;
    *b = *a;
    *a = tmp;
}

int
main() 
{
    int n;
    scanf("%d", &n);
    int **a = calloc(n, sizeof(*a));
    for (int i = 0; i < n; ++i) {
        a[i] = calloc(n, sizeof(*a[i]));
        for (int j = 0; j < n; ++j) {
            scanf("%d", &a[i][j]);
        }
    }
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < i; ++j) {
            swap(&a[i][j], &a[j][i]);
        }
    }
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            printf("%d ", a[i][j]);
        }
        printf("\n");
    }

    return 0;
}
```

Про то, что такое матрица и её транспонирование, можно прочитать [здесь](https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D1%82%D1%80%D0%B8%D1%86%D0%B0_(%D0%BC%D0%B0%D1%82%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0)).

Также в Си бывает более правильно работать с матрицами как с одномерными массивами. Продемонстрируем это на том же примере:

```c
#include <stdio.h>
#include <stdlib.h>

void 
swap(int *a, int *b)
{
    int tmp = *b;
    *b = *a;
    *a = tmp;
}

int
main()
{

    int n;
    scanf("%d", &n);
    int *a = calloc(n, sizeof(*a));
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            scanf("%d", &a[i * n + j]);
        }
    }
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < i; ++j) {
            swap(&a[i * n + j], &a[j * n + i]);
        }
    }
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            printf("%d ", a[i * n + j]);
        }
        printf("\n");
    }

    return 0;
}
```
























































