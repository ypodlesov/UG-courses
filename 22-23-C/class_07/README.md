# Тестирование и отладка на языке Си

В данном разделе мы обсудим некоторые вещи необходимые для тестирования написанных программ и их корректирования в 
случае ошибок. 

## Что такое corner case (также называется edge case)

Проще говоря, **corner case** - это пограничный случай. Например, мы написали функцию принимающую на вход количество элемнтов, 
массив и сортирующую его. Мы проверили, что она корректно работает при количестве элементов равном 1, 2, 3 и так далее. 
Но мы не уверены в том, что она сделает при неположительном размере массива или слишком большом размере 
(допустим больше 10^6^) массива. И мы можем договориться о том, что в этих двух 
случаях она просто вернёт указатели. И если так и будет, то мы скажем что функция 
верно отрабатывает **corner case**.

## Отработка ошибок

Возвращаясь к прошлому случаю, мы можем договориться что вместо возврата того же указателя функция сразу же завершится 
с ошибкой. 

Например:

```c
enum
{
    MILLION = 1000000
}

void mysort(int n, int *a) {
    if (n <= 0) {
        fprintf(stderr, "error! non-positive size\n");
        exit(1);
    } 
    if (n > MILLION) {
        fprintf(stderr, "error! too large array\n");
        exit(2);
    }
    // ...
}
```

Функция `fprintf` аналогична функции `printf`, кроме того, что первым аргументом (перед форматной строкой) указывается 
поток на который происходит вывод. По умолчанию всё, что выводится на `stderr` видно в консоли. То есть существенной 
разницы на данном этапе между ними нет. 

Функция `exit(int exit_code)` пока что стоит воспринимать как `return exit_code`. 

Также для отлавливания ошибок, можно создать глобальную переменную, которая перед каждым вызовом нажей функции будет 
обнуляться а внутри функции, если происходит ошибка, то функция выставляет этой переменной значение, которое 
соответствует произошедшей ошибке и сразу завершается с ненулевым кодом возврата. Отличие от предыдущего метода в том,
что мы не выводим ничего в поток ошибок, а оставляем это на откуп вызывающей функции.

Например:

```c

enum
{
    MILLION = 1000000
}

#define INCORRECT_SIZE(A) (((A) == -1) ? 1 : 0)
int error;

int 
sort(int n, int *a) 
{
    if (n <= 0) {
        error = 1;
        exit(1);
    } 
    if (n > MILLION) {
        error = 1;
        exit(1);
    }
    // ...
}

int 
main() 
{
    // int n = ...
    // int *a = ...
    error = 0;
    sort(n, a);
    if (INCORRECT_SIZE(n)) {
        fprintf(stderr, "error in sort! incorrect size, array was not sorted\n");
    }
    // ...
}
```

## Аргументы командной строки

На самом деле аргументы функции `main` передаются. Сейчас мы рассмотрим некоторые из них, а именно `int argc` и 
`char *argv[]`.

- `int argc` - количество аргументов в массиве указателей `argv[]`
- `char *argv[]` - массив указателей на строки - сами аргументы. При этом первым аргументом всегда идёт имя 
исполняемого файла.

Напишем простую программу использующую аргументы командной строки.

```c
#include <stdio.h>
#include <stdlib.h>

int error;

#define INCORRECT_POINTER(A) ((A) == -1 ? 1 : 0)
#define INCORRECT_FORMAT(A) ((A) == 1 ? 1 : 0)
#define LARGE_NUMBER(A) ((A) == 2 ? 1 : 0)

int 
check_is_digit(char ch) 
{
    if (ch - '0' < 0 || ch - '0' > 9) return 0;
    return 1;
}

int 
convert_str_to_int(char *str) 
{
    if (str == NULL) {
        error = -1;
        exit(1);
    }
    long long res = 0;
    for (int i = (check_is_digit(str[0]) ? 0 : 1); str[i] != '\0'; ++i) {
        if (!check_is_digit(str[i])) {
            error = 1;
            exit(2);
        }
        res = res * 10 + (int) (str[i] - '0');
        if (res != (int) res) {
            error = 2;
            exit(3);
        }
    }
    if (str[0] == '-') res *= -1;
    else if (!check_is_digit(str[0]) && str[0] != '+') {
        error = 1;
        exit(2);
    }
    return (int) res;
}

int
main(int argc, char *argv[]) 
{
    for (int i = 1; i < argc; ++i) {
        error = 0;
        int res = convert_str_to_int(argv[i]);
        if (INCORRECT_POINTER(error)) {
            fprintf(stderr, "error! passed to convert_str_to_int NULL in args\n");
        } else if (INCORRECT_FORMAT(error)) {
            fprintf(stderr, "error! passed to convert_str_to_int not correct string\n");
        } else if (LARGE_NUMBER(error)) {
            fprintf(stderr, "error! passed number to convert_str_to_int is too large\n");
        } else {
            printf("%d\n", res);
        }
    }
}
```

Данная программа обрабатывает строки в аргументах командной строки. Каждую строку мы пытаемся конвертировать в число.
При этом ошибки обрабатывает соответстующим образом.

## Отладка программ

Допустим мы совершили ошибку в программе. Большой программе. Нам требуется найти эту ошибку. Этот процесс называется
отладкой программы. Самым протым инструментом, отладочной печатью, пользовались почти все. Сейчас мы рассмотрим основы 
более совершенного и функционвльного инструмента отладки, а именно отладчика **gdb** (на **MacOS** это **lldb**).

Краткая справка по отладчику **gdb** (те же команды для **lldb**):

- `gcc -g prog.c -o prog` - компиляция с отладочной информацией
- `gdb prog` - запуск отладчика
- `quit` - завершнени работы отладчика 
- `run` - запуск программы на выполнение. Команда доступна только, если программа еще не запущена. При подключении к 
работающему процессу или исследовании core-файлов данная команда не доступна. Допускается указывать аргументы 
командной строки и перенаправление потоков ввода-вывода, как если бы программа запускалась командным процессором. 

Пример: `run < 001.in > 001.out`

Здесь программа запускается на выполнение с файлом `001.in`, перенаправленным на 
стандартный поток ввода, и файлом `001.out`, в который перенаправляется вывод на стандартный поток вывода. Выполнение 
программы может быть прервано в любой момент нажатием на комбинацию **Ctrl-C**. Отладчик приостановит выполнение 
программы и выдаст приглашение ко вводу очередной команды отладчика.

- `bt` или `backtrace` – распечатать стек вызовов. Стек вызовов печатается от самой вложенной функции к функции main. 
Для каждого стекового фрейма печатается адрес в коде точки вызова, название функции и параметры, переданные в функцию, 
а также позиция в исходном коде. Команда `bt full` дополнительно печатает значения локальных переменных.

- `up` – переход на указанное количество фреймов вверх по стеку вызовов функций. Если аргумент у команды не указан, 
он принимается равным 1 (переход на один фрейм вверх, то есть переход к функции, которая вызвала текущую функцию).

- `down` – переход на указанное количество фреймов вниз по стеку вызовов функций. Если аргумент у команды не указан,
он принимается равным 1 (переход на один фрейм вниз, то есть переход к функции, которая была вызвана в текущей точке 
текущей функции).

- `info frame` – получить информацию о текущем стековом фрейме.

- `info locals` – получить информацию о значениях локальных переменных текущего стекового фрейма.

- `p` или `print` – напечатать значение выражения. Аргументом команды может быть почти произвольное выражение языка Си, 
даже включающее в себя вызовы функций программы, если, конечно, отлаживаемый процесс существует. Таким образом, вызовы 
функций недоступны при «посмертной» отладке. Если аргумент команды не указан, берется аргумент, который был указан в 
команде p в последний раз.

- `l` или `list` – напечатать исходный код. Команду можно использовать во многих вариантах, часть из которых 
перечислена ниже.

```console
(gdb) l напечатать очередные 10 строк исходного файла
(gdb) l напечатать предыдущие 10 строк исходного файла
(gdb) l 200 напечатать 10 строк в окрестности 200 строки текущего файла
(gdb) l prog.c:200 (gdb) l main напечатать 10 строк в окрестности 200 строки файла prog.c
(gdb) l *0x0806e502 напечатать 10 строк в окрестности начала функции main напечатать 10 строк в окрестности кода по 
указанному адресу
```

- `b` или `break` – установка точки останова. Параметром команды является точка в программе, помечаемая как точка 
останова. Команду можно использовать во многих вариантах, часть из которых перечислена ниже.

```console
(gdb) b main установить точку останова в начале функции main
(gdb) b 200 установить точку останова на 200
(gdb) b prog.c:200 строке текущего файла установить точку останова на 200 строке файла prog.c
(gdb) b *0x0806e502 установить точку останова по указанному адресу 
```

- `c` или `continue` – продолжить выполнение программы.

- `finish` — продолжить выполнение программы до достижения конца текущей функции

- `n` или `next` — сделать указанное количество шагов выполнения (по умолчанию 1). Вызовы функций рассматриваются 
как одна инструкция, то есть вызванные функции выполняются в обычном, а не пошаговом режиме.

## Тестирование вашего кода

В данной теме мы попробуем протестировать функции и полноценные программы, которые имеют какой-то вывод 
(для простоты будем считать, что вывод происходит на консоль). Главное отличие не в том, что первое - функция, 
второе - полноценный файл, а в том, что в первом случае мы проверяем состоянние данных на уровне программы, то есть 
элементы массива, значение переменной и так далее, а во втором случае мы смотрим на отображение в консоли, в том числе 
расставление пробелов, регистр букв и прочее (то есть исследуем вывод не только с точки зрения содержания, но и внешнего 
вида). Все примеры будем демонстрироать на примере пузырьковой сортировки. Исходники можно посмотреть в соответствующих
дирректориях (**test_func** и **test_prog**).

### Тестирование функции

Допустим у нас есть написанная фукнция сортировки в отдельном файле **bubble_sort.c** с заголовочным файлом 
**bubble_sort.h**. Для начала можно вручную проверить её работоспособность на нескольких базовых тестах, далее проверить
на "корнер кейсах". Если она верно показала себя на всех этих начальных тестах, можно переходить к более тщательному 
тестированию. 

Мы воспользуемся следующим алгоритмом:
1. Пусть `t` вводится в аргументах командной строки.
2. Будем генерировать `t` случайных массивов.
3. Случайный массив представляет из себя массив случайной длины, состоящий из случайных элементов. Предварительно 
установим диапазон случайных чисел.
4. Для каждого случайного массива создаём копию.
5. Сортируем оригинальный массив библиотечной функцией `qsort`, а компию написанной нами `bubble_sort`.
6. Сравниваем массивы.

### Тестирование вывода программы

Именно такое тестирование применяется к вашим программам на Яндекс.Контест, Информатикс и так далее. Мы реализуем 
наиболее простую версию на чистом языке Си без использования других средств.

Алгоритм прост:

1. Имеем три программы: `solution.c` - тестируемое решение, `ans.c` - корректное решение, `check.c` - программа, 
осуществляющая само тестирование.
2. Сразу скомпилируем `solution.c` и `ans.c` в исполняемые файлы с соттветствующими именами.
3. Пусть `t` вводится в аргументах командной строки.
4. Будем генерировать `t` случайных массивов и выводить их в файл с именем: "{номер теста} + {некоторый суффикс 
(например, ".in")}".
5. Выполняем на каждом тесте наши программы и вывод помещаем соответственно в разные файлы.
6. Сравниваем два файла полученных от `solution` и `ans`. 
7. Также в процессе проверки могут случиться разные ошибки, например: программа с решением не скомпилировалась,
ошибка во время выполнения нашего решения и прочее, программа `check.c` должна корректно отрабатывать все эти случаи. 

В коде используется функция `int system(char *command)`, которая принимает в аргументах единственную строку. Короче 
говоря, всё что она делает - пытается выолнить эту строку в терминале и возвращает значение, которое вернул терминал в 
результате выполнения этой комманды. 

Реализации данных простых идей можно посмотреть в файлах к занятию. 

### Измерение времени работы программы или модуля

В языке Си для работы с временем в наносекундах есть следующие средства:

1. Специальная структура:
```c
struct timespec {
    time_t tv_sec; // целые секунды, допустимые значения >= 
    long tv_nsec; // наносекунды, допустимые значения в отрезке [0, 999999999]
}
```
2. Функция
```c
int timespec_get(struct timespec *ts, int base);
```
которая прнимает на вход адрес структуры `timespec`, в которую кладёт значения начиная с момента `base` (в этом 
параметре лучше просто всегда передавать `TIME_UTC`). 

> Задание: попробуйте встроить измерение времени в программы `check.c` для проверки работы функции/вывода программы. 















