
# Теоретико числовые алгоритмы. Часть 1.

## Элементарные понятия теории чисел

### Делимость и делители

Говорят, что целое число $a$ **делится** на число $d$, если существует такое
целое число $k$, что $a = kd$. Обозначение: $d$ $\mid$ $a$. Иначе $d$ $\nmid$ $a$.
При этом число $a$ называется **делимым**, число $d$ - **делителем**, а число $k$ - их **частным**. 
Также говорят, что $a$ кратно $d$.

Каждое число $a$ имеет **тривиальные делители** $1$ и $a$. Все остальные
делители числа $a$ называют **множителями**.

### Простые и составные чиcла

Число $a > 1$ называется **простым**, если его единственные делители - $1$ и
$a$, то есть число $a$ имеет только тривиальные делители. Иначе число $a > 1$ называется **составным**.
Ниже приведены первые 20 простых чисел:

$$
2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71
$$

### Теорема о делении, остатки и равенство по модулю

**Теорема о делении:** Для любого целого $a$ и любого положительного целого $n$
существует единственная пара целых чисел $q$ и $r$, таких, что $0 \le r < n$ и
$a = qn + r$.

При этом число $r$ называется **остатком** от деления. Обозначают также 
$a \equiv r \mod n$ - $a$ равно $r$ **по модулю** $n$

### Общие делители и наибольший общий делитель

Если число $d$ делит число $a$ и число $b$, то число $d$ называется их **общим 
делителем**. 

Важное свойство общего делителя: если $d$ $\mid$ $a$ и $d$ $\mid$
$b$, то $d$ $\mid$ $(a + b)$ и $d$ $\mid$ $(a - b)$.


Наибольший общий делитель обозначается так: $\gcd(a, b)$. 

$\gcd(0, 0) = 0$ - принято считать по определению.

Свойства $\gcd(a, b)$:
1. Если $a \ne 0$ и $b \ne 0$, то $\gcd(a, b) \in \overline{1, \min(|a|, |b|)}$
2. $\gcd(a, b) = \gcd(b, a)$
3. $\gcd(a, b) = \gcd(-a, b)$
4. $\gcd(a, b) = \gcd(|a|, |b|)$
5. $\gcd(a, 0) = |a|$
6. $\gcd(a, ka) = |a|$, $\forall k \in \mathbb{Z}$
7. Если $d$ $\mid$ $a$ и $d$ $\mid$ $b$, то $d$ $\mid$ $(ax + by)$, $\forall x, y \in \mathbb{Z}$

**Теоремы:** Если $a$ и $b$ - произвольные целые числа, не равные одновременно
нулю, то величина $\gcd(a, b)$ равна наименьшему положительному элементу
множества { $ax + by$ | $x$, $y$ $\in \mathbb{Z}$ }.

**Следствие 1:** Для любых целых чисел $a$ и $b$ и произвольного неотрицательного
целого числа $n$ выполнено: 
$$\gcd(na, nb) = n\gcd(a, b)$$ 

**Следствие 2:** Для всех положительных целых чисел $n$, $a$ и $b$ из $n$ $\mid$
$ab$ и $\gcd(a, n) = 1$ следует, что $n$ $\mid$ $b$.

### Взаимно простые целые числа

Числа $a$ и $b$ называются **взаимно простыми**, если $\gcd(a, b) = 1$.

**Теорема:** Для любых целых чисел $a$, $b$ и $p$ таких, что $\gcd(a, p) = 1$,
$\gcd(b, p) = 1$ выполнено: $\gcd(ab, p) = 1$. 

Числа $n_1, n_2, \ldots, n_k$ называются **попарно взаимно простыми**, если для
любых $i \ne j$ выполнено $\gcd(n_i, n_j) = 1$.

**Теоремы:** Для любого простого числа $p$ и всех целых чисел $a$ и $b$ из
условия $p$ $\mid$ $ab$ следует хотя бы одно из утверждений: $p$ $\mid$ $a$, $p$
$\mid$ $b$.

**Теорема (о единственности разложения на множители):** Имеется единственный
способ представления составного числа $a$ в виде произведения 
$$a = p_1^{e_1}p_2^{e_2} \ldots p_r^{e_r}$$
где $p_i$ - простые числа, $p_1 < p_2 < \ldots < p_r$, а $e_i$ -
положительные целые числа.

Такое представление числа называется его **факторизацией**.

## Вычисление факторизации числа

Факторизовать число $n$ можно следующим образом:

Пусть мы имеем простые числа $p_1$, $\ldots$, $p_r$, где $p_r$ - наибольшее
такое, что $p_r^2 \le n$, тогда:

```
Factor(n, P)
    i = 1
    A = empty_set()
    while n > 1
        p = P[i]
        while n mod p == 0
            A.add(p)
            n = n / p
        i = i + 1
```

Время работы данного алгоритма в худшем случае порядка $O(\sqrt{n})$.

Данный алгоритм является тривиальным, но появляется вопрос как быстро найти
набор $p_1$, $p_2$, $\ldots$, $p_r$, то есть как найти все простые числа из
сегмента $[2, \sqrt{n}]$? 

Наивный алгоритм состоит в том, чтобы каждое число из указанного диапазона
проверить на простоту (какая будет временная сложность данного решения?). 
Но это решение неэффективно. 

## Решето Эратосфена

Идея **решета Эратосфена** состоит в том, что изначально, мы помечаем все числа
из сегмента $[2, n]$ как простые. Затем отсеиваем составные следующим образом:
сначала отсеиваем все числа, делящиеся на 2, потом на 3, на 5 и так далее. То
есть на каждом шагу алгоритма, мы выбираем наименьшее число помеченное как
простое и отсеиваем все кратные ему числа.

```
Erat(prime, n)
    prime = array(n, 1) // делаем массив размера n заполненный единицами
    prime[0] = prime[1] = false
    for i = 2 ... n
        if prime[i]
            for j = i * i; j <= n; j += i
                prime[j] = false
```

Временная сложность решета Эратосфена $O(n\log\log(n))$. Причем величина
$\log\log(n)$ очень медленно растёт, поэтому чуть более грубой оценкой будет
$O(n)$.

## Алгоритм евклида

Открыт вопрос, как вычислить $\gcd(a, b)$?

Наивный метод состоит в использовании факторизации числа (каким образом?).

**Рекурсивная теорема о наибольшем общем делителе:** Для любого неотрицательного
целого числа $a$ и любого положительного целого числа $b$ справедливо
соотношение 
$$\gcd(a, b) = \gcd(b, a \mod b)$$

На этом утверждении и построен **алгоритм Евклида**. 

Приведём его псевдокод:

```
Euclid(a, b)
    if b == 0
        return a
    else 
        return Euclid(b, a mod b)
```

В худшем случае алгоритм Евклида имеет временную сложность $O(n)$, где n -
битность чисел в его аргументах. К слову худший случай работы алгоритмы - два
последовательных числа фиббоначи (почему?).

### Расширенный алгоритм евклида

Расширенный алгоритм Евклида позволяет вычислить не только наибольший общий
делить, но и коэффициенты $x$ и $y$ такие, что 

$$d = \gcd(a, b) = ax + by$$

Для этого исходный алгоритм Евклида нужно модифицировать следующим образом: 

```
Extended-Euclid(a, b)
    if b == 0
        return (a, 1, 0)
    else 
        (d', x', y') = Extended-Euclid(b, a mod b)
        (d, x, y) = (d', y', x' - (a / b) * y')
        return (d, x, y)
```

Время работы расширенного алгоритма Евклида такое же как для обычного алгоритма
Евклида.































