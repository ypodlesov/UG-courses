# Сортировки и поиск. Часть 2.

## Сортировка слиянием 

**Сортировка слиянием** - алгоритм основанный на парадигме разделяй и властвуй.
Мы уже обсуждали ранее общий вид алгоритма. Поэтому сейчас приведём конкретную
реализацию.

```
Merge(A, p, q, r)
    n1 = q - p + 1
    n2 = r - q
    L = array(n1 + 1)
    R = array(n2 + 1)
    for i = 1 to n1
        L[i] = A[p + i - 1]
    for j = 1 to n2
        R[j] = A[q + j]
    L[n1 + 1] = INF
    R[n2 + 1] = INF
    i = 1
    j = 1
    for k = p to r 
        if L[i] <= R[j]
            A[k] = L[i]
            i = i + 1
        else 
            A[k] = R[j]
            j = j + 1

Merge-Sort(A, p, r)
    if p < r
        q = (p + r) / 2
        Merge-Sort(A, p, q)
        Merge-Sort(A, q + 1, r)
        Merge(A, p, q, r)
```

Временная сложность алгоритма сортировка слиянием составляет $O(n \lg n)$. Но
данный алгоритм имеет один существенный недостаток - необходимость
дополнительной памяти.

## Сортировка подсчётом

В **сортировке подсчётом** предполагается, что каждый из $n$ входных элементов - 
целое число, принадлежащее интервалу от $0$ до $k$, где $k$ - некоторая целая
константа. Если $k = O(n)$, то время работы алгоритма сортировки подсчетом
равно $O(n)$.

Приведём реализацию сортировки подсчётом:

```
Counting-Sort(A, B, k)
    C = array(0 ... k)
    for i = 0 to k 
        C[i] = 0
    for j = 1 to A.length
        C[A[j]] = C[A[j]] + 1
    for i = 1 to k
        C[i] = C[i] + C[i - 1]
    for j = A.length downto 1
        B[C[A[j]]] = A[j]
        C[A[j]] = C[A[j]] - 1
```

**Любой алгоритм сортировки сравнением в наихудшем случае требует выполнения**
$O(n\lg n)$ **сравнений**.

## Линейный и бинарный поиск

В этом разделе поговорим про задачу поиска элемента в массиве.

Задача для численного массива в общем случае ставится следующим образом:

**Дано:** Массив элементов $a_1, \ldots, a_n$. Дан элемент $key$. 


Тривиальное решение - пройти по всему массиву и проверить все элементы. Работает
в худшем случае за $O(n)$. Мы будем использовать именно его.

Но интерес представляет другая чуть менее общая проблема

**Дано:** Массив элементов $a_1, \ldots, a_n$ такой, что 
$a_1 \le a_2 \le \ldots a_n$. Дан элемент $key$. 

**Найти:** Индекс $i$ такой, что $a_i = c$. Если такого элемента в массиве нет,
то вывести $-1$. 

Здесь можно использовать бинарный поиск. 

Приведём псевдокод: 

```
Binary-Search(A, key)
    left = 1
    right = A.length
    while (left <= right)
        mid = (left + right) / 2
        if key < A[mid]
            right = mid - 1
        if key > A[mid]
            left = mid + 1
        if key == A[mid]
            return mid
    return -1
```

Вообще говоря, бинарный поиск применим ко всем монотонным функциям. То есть
можно переформулировать задачу следующим образом:

**Дано:** Монотонная функция $f(x)$, заданная на множестве ${X}$, и число $key$.

**Найти:** Значение аргумента $x$ такое, что $f(x) = key$. Если такого не
существует вернуть $-1$. 

> Вопрос: что за функция используется для бинарного поиска элемента в массиве?




























