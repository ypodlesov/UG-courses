
# Введение в теорию алгоритмов

## Что такое алгоритм?

Несмотря на то, что алгоритм является интуитивно понятным понятием, приведём
одно из возможных определений. 

**Алгоритм** - это любая корректно определенная вычислительная процедура, на вход
которой подаётся некоторая величина или набор величин и результатом выполнения
которой, являетя выходная последовательность.

С понятием алгоритм связано важное понятие его **корректности**. Алгоритм
называется **корректным**, если для любых его входных данных результатом его работы
являются корректные выходные данные.

Рассмотрим в качестве примера одну из классических задач - задачу
**сортировки**. Дадим ей формальное определение:

**Вход:** Последовательность из $n$ чисел $\langle a_1, a_2, \ldots, a_n \rangle$.

**Выход:** Перестановка $\langle a_1', a_2', \ldots a_n'\rangle$ входной
последовательнсти, такая, что $a_1' \le a_2' \le \ldots \le a_n'$.

Задачу сортировки можно решать многими алгоритмами, приведём для примера один из самых
простых - **сортировку вставками** (**insertion sort**). 

Псевдокод сортировки вставками:

```
for j = 2 to A.length
    key = A[j]
    i = j - 1
    while i > 0 and A[i] > key
        A[i+1] = A[i]
        i = i - 1
    A[i+1] = key
```

Пусть задана последовательность $\langle 5, 2, 4, 6, 1, 3\rangle$. Тогда после
каждого прохода цикла `for` будем иметь:

$$ 
j = 2, \: A = \langle \textcolor{green}{5}, 2, 4, 6, 1, 3 \rangle \xrightarrow{1}
j = 3, \: A = \langle \textcolor{green}{2}, \textcolor{green}{5}, 4, 6, 1, 3 \rangle \xrightarrow{2} 
j = 4, \: A = \langle \textcolor{green}{2}, \textcolor{green}{4}, \textcolor{green}{5}, 6, 1, 3 \rangle \xrightarrow{3} \newline \xrightarrow{3}
j = 5, \: A = \langle \textcolor{green}{2}, \textcolor{green}{4}, \textcolor{green}{5}, \textcolor{green}{6}, 1, 3 \rangle \xrightarrow{4} 
j = 6, \: A = \langle \textcolor{green}{1}, \textcolor{green}{2}, \textcolor{green}{4}, \textcolor{green}{5}, \textcolor{green}{6}, 3 \rangle \xrightarrow{5} 
j = 7, \: A = \langle \textcolor{green}{1}, \textcolor{green}{2}, \textcolor{green}{3}, \textcolor{green}{4}, \textcolor{green}{5}, \textcolor{green}{6} \rangle
$$

## Корректность алгоритма

Докажем корректность алгоритма сортировки вставками с помощью **инварианта цикла**. 

**Инвариант цикла** -- логическое выражение, 
которое остаётся истинным после каждого прохода тела цикла. 
Алгоритм является корректным, если инвариант цикла обладает тремя свойствами:
1. **Инициализация** -- справедливость инварианта цикла перед первой итерацией.
2. **Сохранение** -- если инвариант истинен перед $k$-ой итерацией, то он
   истинен и перед $k+1$-ой итерацией.
3. **Завершение** -- если инвариант истинен, то ответ верный. 


Введём инвариант цикла для нашего алгоритма выше: *после каждой итерации `for` подмассив $A[1\ldots j-1]$
состоит из элементов, которые изначально находились в $A[1\ldots j-1]$, но
теперь отсортированы*. 

Докажем три свойства:
1. **Инициализация:** изначально $j = 2$, $A[1 \ldots j-1] = A[1] = a_1$.
2. **Сохранение:** неформально говоря, в теле `for` происходит сдвиг элементов
   $A[j-1], A[j-2], \ldots$ на одну позицию вправо пока не найдется *подходящее* место для
   $A[j]$, т. е. такое, что $A[j]$ (находясь на новом месте) не меньше предыдущего и строго меньше
   следующего. Таким образом подмассив $A[1 \ldots j]$ станет отсортированным.
   После $j = j + 1$ будет выполнен инвариант.
3. По завершении имеем $j = n + 1$ и $A[1 \ldots j - 1]$ - отсортирован, т. к.
   выполнен инвариант, значит
   отсортирован $A[1 \ldots n]$.

Корректность алгоритма сортировки вставками доказана. $\square$


## Анализ алгоритмов

Анализ алгоритма заключается в том, чтобы предсказать требуемые для  его
выполнения ресурсы. Чаще всего оценивается время. Но также иногда мы будем 
оценивать количество памяти. Встаёт вопрос как оценивать? При детальном его
рассмотрении вопрос весьма сложный. Мы ограничимся лишь немногими определениями.
И сделаем упор на интуитивное восприятие.

**Время работы алгоритма** измеряется в количестве элементарных операций, которые
надо выполнить. 

Под "элементарной операцией" будем понимать арифметическую или логическую
операцию с целым числом (в том числе сравнение). 

**Размер входных данных** зависит от задачи. Во многих задачах это просто
количество входных элементов.

### Анализ сортировки вставками

приведём еще раз код, алгоритма и возле каждой строки пометим сколько раз она
выполняется в алгоритме:

| Строка | Количество повторений |
| ------ | ------ |
| `for j = 2 to A.length` | $n$ |
| `key = A[j]` | $n - 1$ |
| `i = j - 1` | $n - 1$ |
| `while i > 0 and A[i] > key` | $\sum_{j=2}^nt_j$ |
| `A[i+1] = A[i]` | $\sum_{j=2}^n(t_j - 1)$ |
| `i = i - 1` | $\sum_{j=2}^n(t_j - 1)$ |
| `A[i+1] = key` | $n - 1$ |

где $t_j$ - количество проверок условия `while` на $j$-ой итерации внешнего
цикла `for`.

Пусть входная последовательность уже отсортирована, тогда на каждом шаге, мы
будем осуществлять лишь одну проверку в `while`, то есть $t_j = 1$ для всех 
$j \in \overline{2, n}$. 

Таким образом имеем (просто суммируя все строки таблицы 
в столбце количества повторений):

$$T(n) = n + (n - 1) + (n - 1) + (n - 1) + (n - 1) = 5n - 4$$

Теперь пусть входная последовательность отсортирована в порядке, обратном
данному. Тогда $t_j = j$ для всех $j \in \overline{2, n}$. Следовательно:

$$T(n) = n + 3(n - 1) + \frac{n(n + 1)}{2} + n(n - 1)$$

То есть мы рассмотрели лучший и худший случай с точки зрения времени выполнения. 
При дальнейшем анализе алгоритмов, мы будем ориентироваться на худший случай. 

## Разработка алгоритмов

Только что мы рассмотрели алгоритм сортировки вставками. Это пример
**инкрементного** подхода -- мы постепенно решали нашу задачу для всех $j$ от 
$1$ до $n$. 

Ещё одним популярным подходом в разработке алгоритмов является **метод
декомпозиции** или метод **разделяй и властвуй**. Многие алгоритмы разработанные 
таким при помощи этого метода имеют **рекурсивную** структуру. 

Данная парадигма на каждом уровне состоит из 3 шагов:

1. **Разделение** задачи на несколько подзадач, которые представляют собой
   меньшие экземпляры той же задачи.
2. **Властвование** над каждой из подзадач путём её рекурсивного решения. При
   достаточно малом размере подзадачи она может быть решена непосредственно.
3. **Комбинирование** решений каждой подзадачи в решение исходной.

Алгоритм сортировки **слиянием** (**merge sort**) является ярким примером 
этой парадигмы. 

Постановка задачи та же. Разберём алгоритм в очень общем виде:

1. **Разделение:** делим $n$-элементную сортируемую последовательность на две
   подпоследовательности по $n/2$ элементов. 
2. **Властвование:** рекурсивно сортируем последовательности с использованием
   сортировки слиянием.
3. **Комбинирование:** соединяем две отсортированные последовательности для
   получения окончательного отсортированного ответа.

Более подробно сортировка слиянием будет рассмотрена позже.

## Стандартные обозначения и часто встречающиеся функции

Как уже было показано время выполнения алгоритма является функцией зависящей 
от $n$. Например, в худшем случае время выполнения алгоритма сортировки
вставками будет квадратичной функцией от $n$ - количества элементов в входной
последжовательности. 

Краткое обозначение: 
$$T(n) = O(n^2)$$

Какой именно смысл этого выражения мы обсуждать не будем, но введём очень общее 
(строго говоря некорректное) правило -- из функции описывающей время выполнения
алгоритма будем брать самый быстрорастущий член.

Приведём наиболее часто встречающиеся в нашем курсе функции в порядке 
увеличения их скорости роста:

| Функция | $n = 5$ | $n = 10$ | $n = 100$ | $n = 10^3$ | $n = 10^4$ | $n = 10^6$ | $n = 10^8$ | 
| ------- | ------- | -------- | --------- | ---------- | ---------- | ---------- | ---------- |
| $\log_2 n$ | 2,32 | 3,32     | 6,64      | 9,96       | 13,28      | 19,93      | 26,57      | 
| $\sqrt{n}$ | 2,23 | 3,16     | 10        | 31,62      | 100        | $10^3$     | $10^4$     | 
| $n$ |        5    | 10       | 100       | $10^3$     | $10^4$     | $10^6$     | $10^8$     | 
| $n\log_2n$ | 11,6 | 33,2     | 664       | 9960       |$1,3 * 10^5$|$19 * 10^6$ |$26 * 10^8$ |
| $n^2$ |    25     | 100      | $10^4$    | $10^6$     | $10^8$     | $10^{12}$  | $10^{16}$  | 
| $n^3$ |    125    | $10^3$   | $10^6$    | $10^9$     | $10^{12}$  | $10^{18}$  | $10^{24}$  | 
| $2^n$ |    32     | 1024     | $1024^{10} \approx 10^{30}$ |...|...|     ...    |    ...     | 
| $n!$ | 120        | 3.628.800| ...       | ...        | ...        |     ...    |    ...     |
| $n^n$ | 3125      | $10^{10}$  | $10^{200}$  |    ...     |    ...     |     ...    |    ...     | 

Применяя данную таблицу к реальным оценкам времени алгоритмов решения, можно
сделать такие предположения: 
1. Язык **C++**: за 1 секунду $\approx 10^8$ итераций
2. Язык **Python**: за 1 секунду $\approx 10^6$ итераций

То есть **Python** при решении алгоритмических задач в среднем в 100 раз 
медленнее чем **C++**. Связано это в том числе с тем, что **Python** --
интерпретируемый язык программирования, а **C++** -- компилируемый.




































